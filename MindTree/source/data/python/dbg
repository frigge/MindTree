# 1 "init.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "init.cpp"
# 29 "init.cpp"
# 1 "../../lib/data/signal.h" 1
# 15 "../../lib/data/signal.h"
namespace MindTree
{

namespace Signal
{

template<typename... Args>
class Sig
{
public:
    void add(std::function<void(Args...)> fn) {
        callbacks.push_back(fn);
    }

    void operator()(Args... args) {
        for(auto fn : callbacks) fn(args...);
    }

private:
    std::vector<std::function<void(Args...)>> callbacks;
};

template<typename ...Args>
class SignalCollector : public PyExposable
{
public:
    void add(std::string sigEmitter, std::function<void(Args...)> fun) {
        std::cout<<"adding callback for function: "<< sigEmitter << std::endl;
        if(!sigs.count(sigEmitter)) sigs[sigEmitter] = new Sig<Args...>();
        sigs[sigEmitter]->add(fun);
    }

    void operator()(std::string sigEmitter, Args... args)
    {
        std::cout<<"fucking callbacks for function: "<< sigEmitter << std::endl;
        if(sigs.count(sigEmitter))(*sigs[sigEmitter])(args...);
    }

private:
    std::map<std::string, Sig<Args...>*> sigs;
};

template<typename...Args>
struct SignalHandler {
    static SignalCollector<Args...> handler;
};

template<typename...Args>
SignalCollector<Args...> SignalHandler<Args...>::handler;

template<typename ...Args>
SignalCollector<Args...>& getHandler(Args...)
{
    return SignalHandler<Args...>::handler;
}

template<typename ...Args>
SignalCollector<Args...>& getHandler()
{
    return SignalHandler<Args...>::handler;
}

}

}
# 30 "init.cpp" 2



using namespace MindTree;
namespace PyMT{

int getGraphicsCount()
{
    int cnt = 0;


    return cnt;
}

BOOST_PYTHON_MODULE(MT){
    BPy::object main = BPy::import("__main__");
    BPy::object global = main.attr("__dict__");

    BPy::def("registerNodeType", NodeType::registerNodeType);
    BPy::def("unregisterNodeType", NodeType::unregisterNodeType);

    BPy::def("registerNode", PyWrapper::regNode);
    BPy::def("registerWindow", PyWrapper::regWindow);
    BPy::def("getRegisteredNodes", PyWrapper::getRegisteredNodes);







    wrap_all();

}

void wrap_all()
{
    ProjectPyWrapper::wrap();
    DNSpacePyWrapper::wrap();
    DNodeListIteratorPyWrapper::wrap();
    DNodePyWrapper::wrap();
    LLsocketPyWrapper::wrap();
    DSocketListPyWrapper::wrap();
    DSocketPyWrapper::wrap();
    DinSocketPyWrapper::wrap();
    DoutSocketPyWrapper::wrap();
    DAInSocketPyWrapper::wrap();

    MindTree::Signal::getHandler((void*)0)(__PRETTY_FUNCTION__,(void*)0);
}

PyObject* QPointFToPython::convert(QPointF const &pos)
{
    BPy::tuple t = BPy::make_tuple(pos.x(), pos.y());
    return BPy::incref(t.ptr());
}

PyObject* QStringToPython::convert(QString const &s)
{
    BPy::object string(s.toStdString());
    return BPy::incref(string.ptr());
}

PythonToQString::PythonToQString()
{
    BPy::converter::registry::push_back(&convertible, &construct, BPy::type_id<QString>());
}

void* PythonToQString::convertible(PyObject* obj)
{
    if(!PyString_Check(obj)) return 0;
    return obj;
}

void PythonToQString::construct(PyObject *obj, BPy::converter::rvalue_from_python_stage1_data *data)
{
    BPy::object strobj(BPy::handle<>(BPy::borrowed(obj)));
    std::string str = BPy::extract<std::string>(strobj);
    void *storage = ((BPy::converter::rvalue_from_python_storage<QString>*)data)->storage.bytes;
    new (storage) QString(str.c_str());
    data->convertible = storage;
}

PyObject* DSocketListToPython::convert(DSocketList const &l)
{
    BPy::list list;
    LLsocket* iter = l.getFirst();
    while(iter){
        if(iter->socket->getDir() == IN)
            if(iter->socket->getArray())
                list.append<DAInSocketPyWrapper*>(new DAInSocketPyWrapper((DAInSocket*)iter->socket));
            else
                list.append<DinSocketPyWrapper*>(new DinSocketPyWrapper(iter->socket->toIn()));
        else
            list.append<DoutSocketPyWrapper*>(new DoutSocketPyWrapper(iter->socket->toOut()));
        iter = iter->next;
    }
    return BPy::incref(list.ptr());
}

void loadPlugin(QString plugin)
{
    BPy::object main = BPy::import("__main__");
    BPy::object global = main.attr("__dict__");
    BPy::import("sys").attr("path").attr("append")(QDir("../plugins").absolutePath().toStdString());
    try{
        BPy::import(BPy::str(plugin.toStdString()));
    }catch(BPy::error_already_set const &){
        PyErr_Print();
    }
}

void initPython()
{
    PyImport_AppendInittab("MT", &initMT);
    Py_Initialize();

    BPy::to_python_converter<QString, QStringToPython>();
    BPy::to_python_converter<QPointF, QPointFToPython>();
    BPy::to_python_converter<QList<DNode*>, QListToPython<DNode*> >();
    BPy::to_python_converter<QList<DoutSocket*>, QListToPython<DoutSocket*> >();
    BPy::to_python_converter<DSocketList, DSocketListToPython >();
    PythonToQString();

    BPy::object main = BPy::import("__main__");
    BPy::object global = main.attr("__dict__");
    BPy::object mtmodule = BPy::import("MT");
    global["MT"] = mtmodule;
    ProjectPyWrapper *project = new ProjectPyWrapper(FRG::CurrentProject);
    BPy::scope(mtmodule).attr("project") = BPy::ptr(project);
}
}
